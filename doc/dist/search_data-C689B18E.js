searchData={"items":[{"type":"module","title":"Bfi","doc":"Brainf*ck Interpreter in Elixir.\n\nWanted to try my hand at parsing a language. Imperatively, Brainf*ck is trivial to interpret,\nwhich is why I wanted to try it in a functional language like Elixir.","ref":"Bfi.html"},{"type":"module","title":"Examples - Bfi","doc":"Linux\n\n```bash\n  $> ./bfi hello.txt\n  Hello world!\n  $> ./bfi --eval --size=10 \"++++++[>+++++++++<-]>.+++.\"\n  69\n```\n\nWindows\n\n```cmd\n  $> escript bfi hello.txt\n  Hello world!\n  $> escript bfi --eval --size=10 \"++++++[>+++++++++<-]>.+++.\"\n  69\n```","ref":"Bfi.html#module-examples"},{"type":"function","title":"Bfi.eval/2","doc":"Evaluation function that comes after the parsing step.\n\nUses tail-recursion with the state as the accumulator.","ref":"Bfi.html#eval/2"},{"type":"function","title":"State - Bfi.eval/2","doc":"The state is a 3-tuple, composed of the data pointer `dp`, the memory `mem`, and the input queue `input`.","ref":"Bfi.html#eval/2-state"},{"type":"function","title":"Notes - Bfi.eval/2","doc":"- Elixir raises an error when trying to `:print` ASCII values that are greater than 128.\n- Inputting more than one character after an evaluation on `:input` results in queueing the rest of the input for subsequent `:input` calls.\n- When evaluating `:next` and `:prev`, note that `dp` is bounded by 0 and the size of `mem`.\n- When evaluating `:increment` and `:decrement`, note that negative values underflow to 255, and numbers greater than 255 overflow back to 0.","ref":"Bfi.html#eval/2-notes"},{"type":"function","title":"Examples - Bfi.eval/2","doc":"iex> Bfi.parse(\"++++++[>++++++++<-]>.>++++++++++.\") |> Bfi.eval(Bfi.memory(3))\n    0\n    {2, {:array, 3, 0, 0, {0, 48, 10, 0, 0, 0, 0, 0, 0, 0}}, \"\"}\n    iex> Bfi.parse(\",.,.>++++++++++.\") |> Bfi.eval(Bfi.memory(3))\n    01\n    01\n    {1, {:array, 3, 0, 0, {49, 10, 0, 0, 0, 0, 0, 0, 0, 0}}, \"\"}","ref":"Bfi.html#eval/2-examples"},{"type":"function","title":"Bfi.main/1","doc":"","ref":"Bfi.html#main/1"},{"type":"function","title":"Bfi.memory/1","doc":"Creates the initial state for `eval/2`, based on a given `size`","ref":"Bfi.html#memory/1"},{"type":"function","title":"Examples - Bfi.memory/1","doc":"iex> init = Bfi.memory(3)\n    iex> Bfi.parse(\"++++++[>++++++++<-]>.\") |> Bfi.eval(init)\n    {1, {:array, 3, 0, 0, {0, 48, 0, 0, 0, 0, 0, 0, 0, 0}}, \"\"}\n    iex> Bfi.parse(\"-[>-[-]]<\") |> Bfi.eval(Bfi.memory(5))\n    {0, {:array, 5, 0, 0, {255, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, \"\"}","ref":"Bfi.html#memory/1-examples"},{"type":"function","title":"Bfi.parse/2","doc":"Parse characters into tokens and group loops.\n\n> Since Brainf*ck tokens are just characters, lexing can be condensed into this one function.\n\n| Character   | Meaning                                            |\n| ----------  | -------------------------------------------------- |\n| `+`         | Increments the current cell                        |\n| `-`         | Decrements the current cell                        |\n| `>`         | Moves forward by one cell                          |\n| `<`         | Moves backward by one cell                         |\n| `.`         | Outputs the current cell                           |\n| `,`         | Takes an integer input                             |\n| `[`         | When current cell is 0, jump to after matching `]` |\n| `]`         | Jump unconditionally to matching `[`               |\n| ` `   | Read as a comment                                  |","ref":"Bfi.html#parse/2"},{"type":"function","title":"Tokens - Bfi.parse/2","doc":"```\n@env %{\n  ?+ => :increment,\n  ?- => :decrement,\n  ?> => :next,\n  ?< => :prev,\n  ?. => :print,\n  ?, => :input,\n}\n```\n\nBrackets are parsed as nested lists.","ref":"Bfi.html#parse/2-tokens"},{"type":"function","title":"Examples - Bfi.parse/2","doc":"iex> Bfi.parse(\"++.a\")\n    [:increment, :increment, :print, :comment]\n    iex> Bfi.parse(\"-><\")\n    [:decrement, :next, :prev]\n    iex> Bfi.parse(\"-[--].\")\n    [:decrement, [:decrement, :decrement], :print]","ref":"Bfi.html#parse/2-examples"}],"content_type":"text/markdown"}